import streamlit as st
import pandas as pd
import duckdb
import json
import traceback
from langchain_groq import ChatGroq
from langchain.agents import create_agent
from langchain_groq import ChatGroq
from langchain.agents import create_agent


# Backend-only database path (not exposed in the UI)

SQL_AGENT_SYSTEM_PROMPT = f""" You are an agent designed to interact with a SQL database. 
Given an input question, create a syntactically correct sql lite query to run, then look at the results of the query and return the answer. 
You can order the results by a relevant column to return the most interesting examples in the database. 
Never query for all the columns from a specific table, only ask for the relevant columns given the question. 
You have access to tools for interacting with the database. Only use the below tools. Only use the information returned by the below tools to construct your final answer. 
You MUST double check your query before executing it. If you get an error while executing a query, rewrite the query and try again. 
Strict Considerations: 
    -Use JOIN to fetch data from two different tables instead of fetching data individually. 
    -DO NOT make any DML statements (INSERT, UPDATE, DELETE, DROP etc.) to the database. 
    -DO not fetch data individually, use SQL Joins to extract data in a single dataframe 
    - Please use the the final sql query to generate the dataframe 
    - Use the first three letters when using ordermonth column, for example if you need fetch data for the month of January, write Jan instead of January 
    - If the query generated is incorrect, then try again to produce the correct query. 
    - Do not explain the SQL query when it gets generated 
    - RETURN ONLY PLAIN SQL QUERY WITHOUT ANY MARKDOWN FORMATTING OR CODE BLOCKS 
    - DO NOT wrap the SQL query in quotes 
    - Please do not hallucinate and generate data on your own. Answer only according to the query asked. 
    - Please order the data chronologically and not alphabetically always. 
    - If a query returns "None" in any of the answers, do not include it in your answers, go for the next option always. 
    - When performing calculations or generating reports, please use the last available date in the database as the 'current' date, instead of the actual current date. 
    - Never use '≥' or '≤' symbol in your SQL queries that you generate. 
    - Return empty dataset if data returned is of "None" type. 
    - If a user asks to compare monthly data with daily data, instead suggest the user to compare at a monthly, quarterly or at a yearly level, do not write the SQL query on your own.
    - For TREND ANALYSIS questions (containing words like 'trend', 'over time', 'growth', 'monthly', 'quarterly', 'yearly'):
        * Always identify the time period column (date, month, year, ordermonth, etc.)
        * Group by the appropriate time period (ensure proper date/month formatting)
        * Use SUM, AVG, COUNT or other aggregations on the metric column
        * Sort results chronologically by time (oldest to newest)
        * Include both the time period and the aggregated metric in SELECT
        * For months, extract month from date if needed, or use the ordermonth column directly
        * Example pattern: SELECT ordermonth, SUM(amount) as total_sales FROM table GROUP BY ordermonth ORDER BY ordermonth
    - NEVER RETURN ANYTHING OTHER than PLAIN SQL QUERY OR ERROR MESSAGE. """


SQL_VALIDATION_PROMPT = """
You are a SQL Validator Agent.

Your job is to VALIDATE and FIX SQL queries generated by another model.

Strict Rules:
- Ensure SQL is syntactically correct.
- Ensure it ONLY uses tables/columns mentioned in the metadata `{columns_map}`.
- Ensure it does NOT hallucinate tables or columns.
- No DML allowed (no INSERT, UPDATE, DELETE, DROP, ALTER, TRUNCATE).
- Must follow strict rules from project:
    - Always use JOIN instead of individual table fetch
    - Never select *
    - Order chronologically, not alphabetically
    - Never use ≥ or ≤ symbols
    - Return ONLY plain SQL, no explanation
- If the SQL is invalid → FIX IT and return corrected SQL.
- If the SQL is valid → just return the same SQL.
- If SQL is empty or nonsensical → write: ERROR_INVALID_SQL

Output must follow response_format: only the corrected SQL.
"""


def get_db_metadata(db_path, sample_limit):
    con = None
    try:
        con = duckdb.connect(db_path, read_only=True)

        tables = con.execute("""
            SELECT table_name
            FROM information_schema.tables
            WHERE table_schema = 'main'
        """).fetchall()

        tables_list = [t[0] for t in tables]

        columns_map = {}
        sample_rows_map = {}

        for table in tables_list:
            raw_columns = con.execute(f"""
                SELECT column_name
                FROM information_schema.columns
                WHERE table_name = '{table}'
            """).fetchall()

            col_list = [c[0] for c in raw_columns]
            columns_map[table] = col_list

            sample_df = con.execute(f"SELECT * FROM {table} LIMIT {sample_limit}").df()
            sample_rows_map[table] = sample_df.to_dict(orient="records")

        return tables_list, columns_map, sample_rows_map
    finally:
        if con:
            con.close()




def context_agent_summary(history, llm):
    """Summarize the session history into a short context string using the LLM agent.
    History is a list of dicts: {"role": "user"/"assistant", "text": ...}
    """
    if llm is None or create_agent is None:
        # Fallback: simple concatenation of last 5 user messages
        user_msgs = [h['text'] for h in history if h['role'] == 'user'][-5:]
        return ' | '.join(user_msgs) if user_msgs else ''

    system_prompt = (
        "You are a context summarizer. Given the session Q&A, produce a concise context summary "
        "(2-3 short sentences) that can help generate future SQL queries. Do not add commentary."
    )
    agent = create_agent(model=llm, system_prompt=system_prompt)
    messages = [{"role": "user", "content": json.dumps(history[-10:])}]
    try:
        result = agent.invoke({"messages": messages})
        return result['messages'][-1].content
    except Exception:
        return ''


def gen_sql(question, tables_list, columns_map, sample_rows_map, prompt, llm):
    if llm is None or create_agent is None:
        # fallback naive SQL: direct aggregation on amazon_sale_report if present
        if 'amazon_sale_report' in tables_list:
            return (
                "SELECT category, SUM(amount) AS total_sales "
                "FROM amazon_sale_report "
                "WHERE status = 'Shipped - Delivered to Buyer' "
                "GROUP BY category ORDER BY total_sales DESC LIMIT 5"
            )
        return "ERROR_NO_LLM"

    agent = create_agent(model=llm, system_prompt=prompt)
    messages = [
        {"role": "system", "content": f"Here is some context about the columns in the table before picking the tables and columns list for the given question: {columns_map}"},
        {"role": "user", "content": f"Here provided sample rows of data for each table to clear context of data to generate a sql query for given question: {sample_rows_map}"},
        {"role": "user", "content": f"user question: {question}"},
    ]
    result = agent.invoke({"messages": messages})
    return result["messages"][-1].content


def validate_sql(sql_query, columns_map, llm):
    if llm is None or create_agent is None:
        return sql_query

    validator_prompt = SQL_VALIDATION_PROMPT.replace("{columns_map}", str(columns_map))
    validation_agent = create_agent(model=llm, system_prompt=validator_prompt)
    result = validation_agent.invoke({"messages": [{"role": "user", "content": sql_query}]})
    return result['messages'][-1].content


def run_query_on_duckdb(sql, db_path="salesdata.duckdb", max_retries=3):
    """Execute SQL query with retry logic to handle lock conflicts"""
    import time
    conn = None
    for attempt in range(max_retries):
        try:
            conn = duckdb.connect(db_path, read_only=True)
            df = conn.execute(sql).fetchdf()
            return df
        except Exception as e:
            error_msg = str(e).lower()
            if "lock" in error_msg and attempt < max_retries - 1:
                wait_time = 0.5 * (2 ** attempt)
                print(f"Database lock detected. Retrying in {wait_time}s (attempt {attempt + 1}/{max_retries})")
                time.sleep(wait_time)
                continue
            else:
                return f"SQL Execution Error: {e}"
        finally:
            if conn:
                try:
                    conn.close()
                except:
                    pass


def gen_nl(question, df_json, llm):
    if llm is None or create_agent is None:
        return "(No LLM available)"

    nl_response_prompt = (
        "You are an assistant to generate a Natural Language (NL) response based on the provided data and the user's question. "
        "Provide a short, business-friendly answer derived only from the provided dataframe. If dataframe is empty, reply: sorry unable to find relevant data."
    )
    nl_agent = create_agent(model=llm, system_prompt=nl_response_prompt)
    try:
        result = nl_agent.invoke({"messages": [{"role": "user", "content": question}, {"role": "user", "content": df_json}]})
        return result["messages"][-1].content
    except Exception:
        return "(NL generation failed)"



